[{"content":"HTTP请求 ","date":"2024-03-19T00:00:00Z","image":"https://etherealboyjiang.github.io/Jiang/img/Jmeter/0.png","permalink":"https://etherealboyjiang.github.io/Jiang/p/jmeterhttp%E8%AF%B7%E6%B1%82/","title":"JmeterHTTP请求"},{"content":"线程组 线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。线程组元件是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。将线程组视为一个虚拟用户池，其中每个线程可被理解为一个虚拟用户，多个虚拟用户同时执行相同的一批任务。在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 执行顺序 在JMeter中，setUp线程组拥有最高的优先级，而tearDown线程组则具有最低的优先级。这一优先级关系可用表达式表示为：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n这意味着在测试计划执行过程中，setUp线程组将首先执行，其后是线程组和开放模型线程组，最后执行tearDown线程组。通常情况下，setUp线程组用于在测试执行之前进行一些初始化工作，而tearDown线程组用于测试执行结束后的清理工作。其他线程组在测试执行过程中按照它们在测试计划中的顺序执行。\n这种优先级的设定确保了在测试的前后可以进行一些全局性的准备和清理工作，以确保测试环境的稳定性和一致性。这种有序的执行流程使得在性能测试中能够更灵活地控制测试场景，并确保测试的准确性和可重复性。\n示例接口代码 1 2 3 4 5 6 7 8 9 @api.route(\u0026#39;/ThreadGroup/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 if request.method != \u0026#39;POST\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39; 请求方式错误！\u0026#39;}) data = request.get_json() if \u0026#34;ThreadGroupName\u0026#34; not in data: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;请求参数错误!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;线程组类型是：\u0026#39; + data[\u0026#34;ThreadGroupName\u0026#34;]}) 示例Jmeter脚本 在测试计划中，分别添加tearDown线程组、线程组、setUp线程组\n在tearDown线程组、线程组、setUp线程组下分别添加HTTP请求 取样器\n名称分别为：tearDown线程组请求、线程组请求、setUp线程组请求\n请求地址：HTTP://127.0.0.1:5000/ThreadGroup/\n请求方式：POST\n消息体数据分别为：{\u0026ldquo;ThreadGroupName\u0026rdquo;: \u0026ldquo;tearDown线程组请求\u0026rdquo;}\n{\u0026ldquo;ThreadGroupName\u0026rdquo;: \u0026ldquo;线程组请求\u0026rdquo;}\n{\u0026ldquo;ThreadGroupName\u0026rdquo;: \u0026ldquo;setUp线程组请求\u0026rdquo;}\n在tearDown线程组请求、线程组请求、setUp线程组请求取样器下添加HTTP信息头管理器\n名称：Content-Type\n值：application/json\n在测试计划下添加查看结果树\n运行，查看结果树 setUp线程组请求的取样器结果\rhread Name:setUp 线程组 1-1 1-1\nSample Start: 2024-02-01 11:30:38 CST\nLoad time:3009\nConnect Time:2\nLatency:3009\nSize in bytes:266\nSent bytes:210\nHeaders size in bytes:224\nBody size in bytes:100\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\nHTTPSampleResult fields:\nContentType: application/json\nDataEncoding: null\r线程组请求的取样器结果\rhread Name:线程组 1-1\nSample Start: 2024-02-01 11:30:41 CST\nLoad time:3004\nConnect Time:1\nLatency:3004\nSize in bytes:260\nSent bytes:219\nHeaders size in bytes:165\nBody size in bytes:95\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\nHTTPSampleResult fields:\nContentType: application/json\nDataEncoding: null\rtearDown线程组请求的取样器结果\rhread Name:tearDown 线程组 1-1\nSample Start: 2024-02-01 11:30:44 CST\nLoad time:3005\nConnect Time:2\nLatency:3005\nSize in bytes:269\nSent bytes:227\nHeaders size in bytes:166\nBody size in bytes:103\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\nHTTPSampleResult fields:\nContentType: application/json\nDataEncoding: null\r可以观察到在中国标准时间（CST）2024-02-01 11:30:38 时，setUp线程组请求取样器发送了请求；随后，在 2024-02-01 11:30:41 CST，线程组请求取样器也发出了请求；最后，在 2024-02-01 11:30:44 CST，tearDown线程组请求取样器发出了请求。\n这与接口设置的休眠时间一致，表明 JMeter 在接收到setUp线程组请求取样器的响应后，执行了线程组操作，然后在接收到线程组请求取样器的响应后，执行了 tearDown线程组 操作。\n总体来说，执行顺序可以归纳为：setUp线程组 \u0026gt; 线程组 \u0026gt; 开放模型线程组 \u0026gt; tearDown线程组。\n结语 JMeter提供的setUp线程组和tearDown线程组功能为我们提供了很多便利。通过使用这两个线程组，我们能够执行一些必要的前置和后置操作，以更有效地进行性能测试。\n举例来说，setUp线程组可用于执行诸如登录、数据库查询等前置操作。这允许我们在性能测试开始前设置测试环境，确保系统处于一种预期的状态，从而更准确地模拟实际用户行为。\n另一方面，tearDown线程组可以用于执行一些关键的清理和还原操作，如删除数据库记录、退出登录等。这有助于确保在测试执行完成后系统状态得到有效还原，减少测试对系统的影响，并提供一致性的测试结果。\n综合而言，通过巧妙地利用setUp线程组和tearDown线程组，我们能够更方便地进行性能测试，确保测试环境的准备和清理工作得到有效管理，从而提高测试的可重复性和准确性。\n在测试计划中，同类型线程组的执行顺序可以通过勾选或不勾选独立运行每个线程组来控制。勾选独立运行每个线程组，则同类型线程组按照从上至下的顺序依次执行；反之，则同类型线程组并发执行。\n线程数 线程组中的线程数指的是同时运行的虚拟用户数量。这个数量决定了你的测试将模拟多少个用户同时访问目标应用程序或服务。\n在JMeter的线程组配置中，你可以根据你的需求来设置线程数，通常是根据你想要模拟的用户负载量和你的系统资源来决定的。\n需要注意的是，线程数设置得太高可能会导致测试机器资源不足，影响测试结果的准确性；而设置得太低可能无法模拟真实的负载情况。因此，需要根据具体情况进行合理的设置。\n示例接口代码 1 2 3 4 5 @api.route(\u0026#39;/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not GET!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;It is successful!\u0026#39;}) 示例Jmeter脚本 在测试计划下，添加1个线程组\n线程数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/QuickUse/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行，查看结果树 用户1-1的取样器结果\rThread Name:线程组 1-1\nSample Start:2024-03-07 13:38:46 CST\nLoad time:34\nConnect Time:24\nLatency:30\r用户1-2的取样器结果\rThread Name:线程组 1-2\nSample Start:2024-03-07 13:38:46 CST\nLoad time:2\nConnect Time:1\nLatency:2\r用户1-3的取样器结果\rThread Name:线程组 1-3\nSample Start:2024-03-07 13:38:46 CST\nLoad time:4\nConnect Time:1\nLatency:4\r可以看出取样器结果中的Thread Name分别为线程组 1-1、线程组 1-2、线程组 1-3，这是因为线程组中线程数值为3，Jmeter启功了3个线程，每个线程皆执行1次线程组。在Jmeter中1个线程就代表1个用户，现在就相当于3个用户一起执行线程组。\n结语 在JMeter中，线程数是指在测试计划中设置的虚拟用户数。这些虚拟用户模拟真实用户的行为，对目标服务器进行请求。设置线程数的目的是为了模拟高负载情况下系统的性能表现。\n线程数的设置通常在JMeter的线程组组件中进行。一个线程组可以包含一个或多个线程，每个线程模拟一个用户。通过增加线程数，可以模拟更多的并发用户，从而测试系统在高并发情况下的性能。\n设置线程数时，需要考虑以下几个因素：\n测试目标：根据你要测试的应用程序的预期负载来设置线程数。\n系统资源：确保JMeter机器有足够的资源来管理这些线程。过多的线程可能会导致JMeter机器资源耗尽。\n服务器容量：线程数不应超过目标服务器的容量，否则可能会导致服务器崩溃或响应缓慢。\n合理地设置线程数对于获得准确的性能测试结果至关重要。通常建议从小规模的线程数开始，逐渐增加，直到达到预期的测试目标或服务器的性能瓶颈。\n循环次数 线程组中的循环次数指的是用户执行测试计划的次数。这个数量决定了你的测试将模拟用户访问目标应用程序或服务的次数。\n在JMeter的线程组配置中，你可以根据你的需求来设置循环次数，通常是根据你想要模拟的用户访问上限值，如抽奖次数。\n需要注意的是，循环次数设置得太高，特别设置循环次数为永远，可能会导致测试机器资源不足，影响测试结果的准确性；而设置得太低可能无法达到测试要求。因此，需要根据具体情况进行合理的设置。\n示例接口代码 1 2 3 4 5 @api.route(\u0026#39;/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not GET!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;It is successful!\u0026#39;}) 示例Jmeter脚本 在测试计划下，添加1个线程组\n循环次数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/QuickUse/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行，查看结果树 取样器结果\rThread Name:线程组 1-1\nSample Start:2024-03-07 13:38:46 CST\nLoad time:3\nConnect Time:1\nLatency:3\r取样器结果\rThread Name:线程组 1-1\nSample Start:2024-03-07 13:38:46 CST\nLoad time:2\nConnect Time:1\nLatency:1\r取样器结果\rThread Name:线程组 1-1\nSample Start:2024-03-07 13:38:46 CST\nLoad time:1\nConnect Time:0\nLatency:1\r可以看出取样器结果中的Thread Name皆为线程组 1-1，这是因为线程组中循环次数值为3，Jmeter启功了1个线程，连续执行了3次线程组。在Jmeter中1个线程就代表1个用户，现在就相当于1个用户执行了3次线程组。\n结语 在JMeter中，循环次数是指每个线程（即虚拟用户）执行其测试计划的次数。这是JMeter线程组中的一个重要设置，它决定了每个线程将重复执行其包含的采样器和其他配置元素的次数。\n设置循环次数时，需要考虑以下几点：\n测试目的：根据你的测试目标来决定循环次数。例如，如果你想要模拟用户在一定时间内持续访问某个页面，那么你可能需要设置较高的循环次数。\n测试持续时间：循环次数与测试持续时间（如果设置了）共同决定测试的总执行次数。如果设置了持续时间，那么循环次数实际上决定了在持续时间结束前每个线程尝试执行的总次数。\n服务器负载：循环次数的增加可能会导致服务器负载的增加。因此，在设置时需要考虑目标服务器的承受能力。\n测试资源：高循环次数可能会增加JMeter的资源消耗，因此需要确保JMeter有足够的资源来处理这些请求。\n在实际的测试场景中，通常建议先从较小的循环次数开始，然后根据测试结果和需求逐渐增加，直到达到满意的测试效果。\n取样器错误后执行的动作 在JMeter中，取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是一些处理取样器错误时，线程组中常见方式：\n停止测试 立即停止测试 停止线程 启动下一进程循环 继续 通过合理配置这些错误处理方式，可以根据测试需求和场景来控制测试计划的行为，确保对错误有适当的响应和处理。\n示例接口代码 1 2 3 4 5 6 @api.route(\u0026#39;/ThreadGroup1/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): if request.method == \u0026#39;GET\u0026#39;: # `错误请求`立即返回 return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;嘿！我有响应！\u0026#39;}) sleep(2) # 延长非`错误请求`的请求时间 return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;嘿！我有响应！\u0026#39;}) 示例Jmeter脚本 在测试计划中，添加2个线程组\n名称分别为：线程组1、线程组2\n在线程组1中，添加3个HTTP请求取样器\n名称分别为：错误请求1、未加固定定时器、错误请求之后请求1\n请求地址：HTTP://127.0.0.1:5000/ThreadGroup1/\n请求方式：错误请求：GET\n未加固定定时器、错误请求之后请求1：POST\n在线程组2中，添加2个HTTP请求取样器\n名称分别为：与错误请求并行请求2、错误请求之后请求2\n请求地址：HTTP://127.0.0.1:5000/ThreadGroup1/\n请求方式：POST\n在错误请求之后请求1、2取样器中，添加固定定时器\n线程延迟（毫秒）：3000\n在错误请求取样器中，添加响应断言\n注释：接口响应与断言值不匹配，则判断该请求出错\n添加响应值：1111\n在测试计划中，添加查看结果树\n错误请求取样器中的响应断言用于判断接口的响应是否与预期的值匹配，如果不匹配，则认为该请求出错。\n固定定时器延迟4秒，可以保证错误请求之后请求2在错误请求1结束后执行。\n停止测试 设置取样器错误后执行的动作为停止测试时，一旦任何一个取样器遇到错误，整个测试计划将会在所有当前正在执行的线程执行完毕后停止。这可以用于模拟在测试过程中发生重要错误或异常时的行为。\n这种设置确保在测试执行中任何关键的错误都会导致测试的终止，以便进行及时的识别和处理。这对于模拟真实世界中的异常情况以及确保测试的准确性和可重复性都是非常重要的。\n多线程组 修改示例脚本 测试计划中勾选独立运行每个线程组\n线程组1放在线程组2前\n运行，查看结果树 连续运行了2次，但结果却不尽相同，与预期不符。取样器在线程组中按从上至下的顺序执行。\n在测试计划中勾选了独立运行每个线程组后，线程组1与线程组2互不干扰且顺序执行，因此，先执行线程组1时出现错误请求，不会影响到执行线程组2。但是结果是线程组2有概率不会执行。\n修改示例脚本 测试计划中勾选独立运行每个线程组\n线程组1放在线程组2后\n运行，查看结果树 连续运行了3次，结果保持一致，与预期相符。取样器在线程组中按从上至下的顺序执行。\n在测试计划中勾选了独立运行每个线程组，所以线程组2与线程组1互不干扰且顺序执行。因此，先执行线程组2，待线程组1中出现错误请求时，测试计划停止测试。\n修改示例脚本 测试计划中取消勾选独立运行每个线程组 运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n在测试计划中未勾选独立运行每个线程组，因此线程组2与线程组1互相干扰且并行执行。当线程组1中出现错误请求时，线程组2中的与错误请求并行请求2也在执行，直到与错误请求并行请求2结束后，测试计划才停止测试。\n建议\n如果测试计划中勾选了“独立运行每个线程组”，不建议非最后排序的线程组中取样器错误后执行的动作设置为停止测试，它并不会按照你的预期去执行。\n单线程组 修改示例脚本 禁用线程组2\n未加固定定时器放在错误请求1前\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n先执行未加固定定时器请求，待错误请求1中出现错误请求时，测试计划停止测试。\n修改示例脚本 禁用线程组2\n错误请求1放在错误请求之后请求1后\n线程组1中的线程数改为3\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n3个用户同时执行线程组1。3个用户中其中1个用户执行错误请求1出现错误时，另外2个用户还在执行错误请求之后请求1，待执行完毕后，测试计划停止测试。\n修改示例脚本 禁用线程组2\n错误请求1放在错误请求之后请求1后\n线程组1中的循环数改为3\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行，1个用户执行线程组13次。用户在执行第1次错误请求1出现错误时，测试计划停止测试。\n立即停止测试 设置取样器错误后执行的动作为立即停止测试时，当取样器在执行过程中遇到错误时，JMeter会立即停止当前运行的测试，不再执行任何后续的请求或操作。\n这有助于保护应用程序免受可能导致问题的异常或错误的影响，并确保测试结果的准确性。\n这种设置对于测试场景中的稳定性和可靠性非常重要，特别是在模拟并发用户或大负载情况下，能够及时发现问题并停止测试，有助于减少潜在的影响和损害。\n多线程组 修改示例脚本 测试计划中勾选独立运行每个线程组\n线程组1放在线程组2前\n运行，查看结果树 连续运行了4次，但结果却不尽相同，与预期不符。取样器在线程组中按从上至下的顺序执行。\n在测试计划中勾选了独立运行每个线程组后，线程组1与线程组2互不干扰且顺序执行。因此，若线程组1中出现错误请求时,不会影响到执行线程组2。但是结果是线程组2有概率不会执行。\n修改示例脚本 测试计划中勾选独立运行每个线程组\n线程组1放在线程组2后\n运行，查看结果树 连续运行了4次，结果保持一致，与预期相符。取样器在线程组中按从上至下的顺序执行。\n在测试计划中勾选了独立运行每个线程组，所以线程组2与线程组1互不干扰且顺序执行。因此，先执行线程组2，待线程组1中出现错误请求时，测试计划立即停止测试。\n修改示例脚本 测试计划中取消勾选独立运行每个线程组 运行，查看结果树 连续运行了4次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n在测试计划中未勾选独立运行每个线程组，因此线程组2与线程组1互相干扰且并行执行。当线程组1中出现错误请求时，线程组2中的与错误请求并行请求2也在执行，但不等与错误请求并行请求2结束，测试计划立即停止测试，可以看出与错误请求并行请求2的响应体中提示 Socket 关闭异常。\n建议\n如果测试计划中勾选了“独立运行每个线程组”，不建议非最后排序的线程组中取样器错误后执行的动作设置为立即停止测试，它并不会按照你的预期去执行。\n单线程组 修改示例脚本 禁用线程组2\n未加固定定时器放在错误请求1前\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n先执行未加固定定时器请求，待错误请求1中出现错误请求时，测试计划立即停止测试。\n修改示例脚本 禁用线程组2\n错误请求1放在错误请求之后请求1之后\n线程组1中的线程数改为3\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n3个用户同时执行线程组1。3个用户中其中1个用户执行错误请求1出现错误时，另外2个用户还在执行错误请求之后请求1， 但不等执行完毕后，测试计划立即停止测试，可以看出与错误请求并行请求1的响应体中提示 Socket 关闭异常。\n修改示例脚本 禁用线程组2\n错误请求1放在错误请求之后请求1后\n线程组1中的循环数改为3\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n1个用户执行线程组13次。用户在执行第1次错误请求1出现错误时，测试计划立即停止测试。\n停止线程 设置取样器错误后执行的动作为停止线程时，当取样器在执行过程中遇到错误时，Jmeter会立即停止当前线程，但不会停止别的线程。\n这可以防止无效或无用的进一步测试，尤其是在错误可能导致后续操作无效的情况下。通过停止出现错误的线程，可以更准确地模拟用户行为和评估系统性能，因为现实世界中的用户通常在遇到问题时不会继续执行相同或相关的操作。 此外，停止出现错误的线程有助于简化错误分析，因为只有出现问题的线程会被停止，从而更容易识别和诊断问题。\n多线程组 修改示例脚本 测试计划中勾选独立运行每个线程组 运行，查看结果树 连续运行了3次，结果保持一致，与预期相符。取样器在线程组中按从上至下的顺序执行。\n在测试计划中勾选了独立运行每个线程组，所以线程组2与线程组1互不干扰且顺序执行。因此，先执行线程组1，待线程组1中的用户出现错误请求时，线程组1的用户线程被停止，接着执行线程组2。\n修改示例脚本 测试计划中取消勾选独立运行每个线程组 运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n在测试计划中未勾选独立运行每个线程组，因此线程组2与线程组1互相干扰且并行执行。待线程组1中的用户出现错误请求时，线程组1的用户线程被停止，线程组2继续执行。\n单线程组 修改示例脚本 禁用线程组2\n线程组1下的错误请求之后请求1\n线程组1中的线程数改为3\n线程组1下添加一个用户参数\n添加步骤：右键线程组-添加-前置处理器-用户参数\n添加变量，名称：dy\n添加三个用户值：{\u0026quot;code\u0026quot;:200,、1111、{\u0026quot;code\u0026quot;:200,\n错误请求1下响应断言的值,引用用户参数中的变量：${dy}\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n每次运行时，三个用户的响应断言值分别引用{\u0026quot;code\u0026quot;:200,、1111、{\u0026quot;code\u0026quot;:200,，导致第二个用户执行错误请求1时发生错误， 结束该用户线程，未执行未加固定定时器。其他用户则未发生错误，可以执行未加固定定时器。因此导致每次会有3个错误请求1执行、但只有2个未加固定定时器执行。\n修改示例脚本 桌面上新建一个dy.txt文件,文本内容为：\n{\u0026quot;code\u0026quot;:200,,\n1111,\n{\u0026quot;code\u0026quot;:200,,\n注意：三个参数不能在一行，每行一个参数。每个参数最后的逗号作用为分隔符。\n禁用线程组2\n线程组1下的错误请求之后请求1\n线程组1中的循环数改为3\n线程组1下添加一个CSV 数据文件设置\n添加步骤：右键线程组-添加-配置元件-CSV Data Set Config\n文件名：dy.txt的路径\n文件编码：UTF-8\n变量名称：dy\n错误请求1下响应断言的值,引用用户参数中的变量：${dy}\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n用户的三次循环的响应断言值分别引用CSV 数据文件设置的{\u0026quot;code\u0026quot;:200,、1111、{\u0026quot;code\u0026quot;:200,，导致用户第二次循环时执行错误请求1时发生错误， 结束该用户线程，未执行之后未加固定定时器和第三次循环。\n启动下一进程循环 设置取样器错误后执行的动作为停止线程时，当取样器在执行过程中遇到错误时，Jmeter会立即停止当前线程本次执行进行当前线程的下次执行，主要应用于线程多次循环时。\n这可以防止无效或无用的进一步测试，尤其是在错误可能导致本次循环后续操作无效的情况下。通过停止出现错误的循环，进行下一次循环，可以更准确地模拟用户行为和评估系统性能，因为现实世界中的用户通常在流程操作中，开始或中间过程遇到问题时不会继续执行后续的操作，会从头开始操作。\n修改示例脚本 桌面上新建一个dy.txt文件,文本内容为：\n{\u0026quot;code\u0026quot;:200,,\n1111,\n{\u0026quot;code\u0026quot;:200,,\n注意：三个参数不能在一行，每行一个参数。每个参数最后的逗号作用为分隔符。\n禁用线程组2\n线程组1下的错误请求之后请求1\n线程组1中的循环数改为3\n线程组1下添加一个CSV 数据文件设置\n添加步骤：右键线程组-添加-配置元件-CSV Data Set Config\n文件名：dy.txt的路径\n文件编码：UTF-8\n变量名称：dy\n6.错误请求1下响应断言的值,引用用户参数中的变量：${dy}\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n每次运行时，用户的三次循环的响应断言值分别引用CSV 数据文件设置的{\u0026quot;code\u0026quot;:200,、1111、{\u0026quot;code\u0026quot;:200,，导致用户第二次循环时执行错误请求1时发生错误， 该用户线程跳过本次循环，不在执行之后未加固定定时器，直接进行第三次循环。\n继续 设置取样器错误后执行的动作为继续时，JMeter将在取样器执行错误时，忽略错误继续执行本线程的后续操作及执行其他线程。\n这种设置通常用于测试过程中，即使某些请求失败，也需要继续执行其他请求，以模拟真实用户的行为。\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n每次运行时，虽然错误请求1取样器发生错误，但还是执行线程组1中后续的请求及线程组2。\n结语 在 JMeter 中，取样器错误后执行的动作提供了多种错误处理方式，可以根据不同的测试需求和场景来选择适当的处理方式。作为用户，在进行测试之前，必须仔细思考并制定可行的测试方案，以合理地运用这些错误处理方式。\n首先，了解应用程序的预期行为以及可能出现的错误情况是至关重要的。这有助于确定何时以及如何使用错误处理方式。例如，在模拟高负载时，可能会出现服务器超载或数据库连接超时等问题。为了使测试更加真实，可以选择在发生这些错误时重试请求，或者暂时停止并记录错误以便进一步分析。\n其次，考虑到测试的目标和性质。如果是性能测试，可能更关注系统的稳定性和吞吐量。在这种情况下，可能会选择忽略某些错误，继续进行测试以观察系统的性能表现。但是，如果是功能测试，那么对错误的处理可能会更为严格，以确保系统在各种情况下都能正确运行。\n最后，在选择错误处理方式时，还需考虑测试环境和资源的限制。例如，在模拟大量用户的情况下，频繁的重试可能会对系统产生额外的负担，导致测试结果不准确。因此，需要权衡利弊，并选择最适合当前情况的处理方式。\n作为用户，在测试之前应该仔细思考，并根据测试需求和场景制定合适的测试方案，以合理地运用 JMeter 中提供的错误处理方式。这样可以确保测试结果的准确性和可靠性，从而更好地评估应用程序的性能和功能。\nramp-up时间 ramp-up时间用于设置启动所有线程所需要的时间。例如：线程数设置为10，ramp-up时间设置为100秒，那么JMeter将使用100秒使10个用户启动并运行，每个用户将在前一个用户启动后的10秒启动。\n如果ramp-up值设置得很小、线程数又设置得很大，刚开始执行测试时会对服务器产生很大的压力。\n示例接口代码 1 2 3 4 5 @api.route(\u0026#39;/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not GET!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;It is successful!\u0026#39;}) 示例Jmeter脚本 在测试计划下，添加1个线程组\n线程数：3\nramp-up时间：30\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/QuickUse/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行，查看结果树 用户1-1的取样器结果\rThread Name:线程组 1-1\nSample Start:2024-03-18 17:55:11 CST\nLoad time:3\nConnect Time:1\nLatency:2\r用户1-2的取样器结果\rThread Name:线程组 1-2\nSample Start:2024-03-18 17:55:21 CST\nLoad time:7\nConnect Time:2\nLatency:6\r用户1-3的取样器结果\rThread Name:线程组 1-3\nSample Start:2024-03-18 17:55:31 CST\nLoad time:4\nConnect Time:1\nLatency:4\r连续运行了3次，结果一致且与预期一致。每个用户的请求时间间隔10秒。\nsame user on each iteration（在每次迭代中使用相同的用户） 没有研究出来它有什么用。经过我的测试，same user on each iteration（在每次迭代中使用相同的用户）启用与否，作用是一样的。\n如读者对此有不同见解，欢迎与我联系，共同探讨。目前，我对此十分费解。\n延迟创建线程直到需要 当在JMeter中启用延迟创建线程直到需要时，JMeter会根据预设的Ramp-up时间动态地分配线程。假设Ramp-up时间设置为20秒，线程数为10，那么JMeter会在测试启动后立即创建第一个线程并开始请求处理。随后，每隔2秒，JMeter将创建下一个线程，直到所有线程都被启动。\n如果关闭“延迟创建线程直到需要”选项，JMeter会在测试开始时一次性创建所有线程。使用同样的参数，即在测试一开始，JMeter会立即创建全部的10个线程。这些线程会按照设定的“Ramp-up时间”进行执行，每个线程将间隔2秒启动。\n延迟创建线程直到需要这一配置的目的是为了应对测试机性能有限的情况。通过这种方式，可以避免在测试初期就创建所有线程，导致资源过度占用和可能的性能问题。这种方法有助于平滑地增加系统负载，同时防止资源瞬间紧张导致测试无法正常进行。\n调度器 调度器主要控制线程操作时间。启用调度器后，可以输入持续时间，启动延迟来控制线程组的操作时间及线程组操作前的延迟时间。\n同时输入持续时间，启动延迟时，先计算启动延迟，再计算持续时间。\n示例接口代码 1 2 3 4 5 @api.route(\u0026#39;/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not GET!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;It is successful!\u0026#39;}) 示例Jmeter脚本 在测试计划下，添加1个线程组\n启用调度器\n启动延迟：3\n持续时间：2\n在线程组下，添加2个HTTP请求取样器\n名称分别为：请求1、请求2\n请求地址：HTTP://127.0.0.1:5000/QuickUse/\n请求方式：GET\n在请求2中，添加固定定时器\n线程延迟（毫秒）：3000\n在测试计划中，添加查看结果树\n运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n每次运行时，Jmeter都会延迟3秒（看右上角）,然后再执行线程组值。由于持续时间设置的是2秒，线程组只会持续执行2秒，而固定定时器的延迟是3，所以不会执行请求2。\n修改示例脚本 禁用请求2中的固定定时器 运行，查看结果树 连续运行了3次，结果一致且与预期一致。取样器在线程组中按从上至下的顺序执行。\n每次运行时，Jmeter都会延迟3秒（看右上角）,然后再执行线程组值。虽然持续时间设置的是2秒，线程组只会持续执行2秒，但没有了固定定时器的延迟，也会执行请求2。\n结语 线程组的关键任务之一是定义并发用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。通过适当配置线程组，测试人员可以模拟多用户在系统中同时执行任务的场景，从而评估系统的性能和稳定性。\n通过灵活使用setup线程组、线程组、tearDown线程组、开放模型线程组，配置前置操作、主要操作、后置操作，更能真实、详细的评估系统。\n线程组在JMeter中扮演着至关重要的角色，通过深入理解和合理配置线程组，读者可以更好地模拟实际用户行为，为性能测试提供更准确的结果。\n","date":"2024-03-19T00:00:00Z","image":"https://etherealboyjiang.github.io/Jiang/img/Jmeter/0.png","permalink":"https://etherealboyjiang.github.io/Jiang/p/jmeter%E7%BA%BF%E7%A8%8B%E7%BB%84/","title":"Jmeter线程组"},{"content":"测试计划 可以将测试计划可视化为用于运行测试的JMeter脚本。测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 前言中的快速开始就是一个测试计划。\n测试计划控制面板中的元素：\n名称和注释\n用户定义的变量\n独立运行每个线程组\n主线程结束后运行tearDown线程组\n函数测试模式\n添加目录或jar包到classpath\n用户定义的变量 当在测试计划的多个部分中存在重复的数值时，可以通过用户定义的变量来提供更灵活的设置。\n测试计划控制面板中的用户定义的变量的作用域覆盖整个测试计划。\n你可以通过${变量名称}的方式来引用这些变量。这种方式允许你在不同的请求或操作中使用相同的数值，从而更加方便地维护和修改。\n示例接口代码： 1 2 3 4 5 6 7 8 9 @api.route(\u0026#39;/TestPlan/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan(): # Jmeter教程测试计划-用户定义的变量api if request.method != \u0026#39;POST\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not POST\u0026#39;}) data = request.get_json() if \u0026#34;UserDefinedVariables\u0026#34; not in data: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request body is error!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;Your request parameters is \u0026#39; + \u0026#39;\u0026#34;UserDefinedVariables:\u0026#39; + data[\u0026#39;UserDefinedVariables\u0026#39;] + \u0026#39;\u0026#34;\u0026#39;})!\u0026#39;}) 示例Jmeter脚本 测试计划面板中添加用户定义的变量\n名称：UserDefinedVariables\n值随意输入：我是用户定义的变量\n测试计划下添加线程组\n线程组下添加HTTP请求\n请求地址：HTTP://127.0.0.1:5000/TestPlan/\n请求方式：POST\n消息体数据:{\u0026quot;UserDefinedVariables\u0026quot;:\u0026quot;${UserDefinedVariables}\u0026quot;}\nHTTP请求下添加HTTP信息头管理器\n右键HTTP请求-添加-配置元件-HTTP信息头管理器，添加信息头，指定请求体类型\n名称：Content-Type\n值：application/json\n测试计划下添加查看结果树\n运行，查看结果树 请求数据\rheaders\rConnection: keep-alive\nContent-Type: application/json\nContent-Length: 58\nHost: 127.0.0.1:5000\nUser-Agent: Apache-HttpClient/4.5.14 (Java/20.0.2)\rbody\rPOST http://127.0.0.1:5000/TestPlan/\nPOST data:\n{\"UserDefinedVariables\":\"我是用户定义的变量\"}\n[no cookies]\r响应数据\rheaders\rHTTP/1.1 200 OK\nServer: Werkzeug/3.0.1 Python/3.12.1\nDate: Mon, 15 Jan 2024 06:19:08 GMT\nContent-Type: application/json\nContent-Length: 132\nConnection: close\rbody\r{\"code\": 200,\"data\": \"Your request parameters is :{\"UserDefinedVariables:我是用户定义的变量\"}\"}\r结语 可以清晰地看出，接口请求参数中调用了用户定义的变量的值:我是用户定义的变量。\n此外，JMeter提供的配置元件中也包含用户定义的变量元件，通过测试计划/线程组/取样器-添加-配置元件-用户定义的变量进行添加。用法与测试计划面板中的用户定义的变量一致，不同之处在于作用域。\n测试计划面板中用户定义的变量具有整个测试计划范围的作用，而配置元件中的用户定义的变量则根据其位置确定作用范围。\n举例来说，在测试计划下添加的用户定义的变量将在整个测试计划中生效，与测试计划面板中的用户定义的变量作用范围一致。然而，如果用户定义的变量位于取样器中，其作用范围将仅限于该特定取样器内。这种灵活性允许在不同配置元件中使用变量，使其作用范围更具体而有针对性。\n建议使用更自由的配置元件中的用户定义的变量 。\n独立运行每个线程组 当一个测试计划下有多个线程组时，且这些线程组都处于执行状态时，可能会使用测试计划中的独立运行每个线程组勾选框，以防止各个线程组之间相互影响。\n在这种情况下，通过勾选独立运行每个线程组，确保每个线程组在执行时都是相互独立的。这意味着它们将不会共享任何变量或资源，从而避免潜在的相互干扰。\n这个选项的使用对于模拟多个并发场景或测试不同业务流程的情况非常重要。它确保每个线程组在测试计划中都能够独立运行，从而更准确地模拟真实世界的使用情境，提高测试的可靠性和准确性。\n示例接口代码 1 2 3 4 5 6 @api.route(\u0026#39;/TestPlan1/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan1(): sleep(3)\t# 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39; 请求方式错误！\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;处理完毕\u0026#39;}) 示例Jmeter脚本 测试计划下添加两个线程组\n名称依次为：线程组1、线程组2\n两个线程组下皆添加取样器\n名称与对应线程组一致：线程组1、线程组2\n请求地址一致：HTTP://127.0.0.1:5000/TestPlan1/\n请求方式一致：GET\n测试计划下添加查看结果树\n运行，查看结果树 不勾选独立运行每个线程组，运行结果 线程组1的取样器结果\rhread Name:线程组1 1-1\nSample Start: 2024-01-16 11:19:34 CST\nLoad time:3004\nConnect Time:1\nLatency:3004\nSize in bytes:231\nSent bytes:210\nHeaders size in bytes:165\nBody size in bytes:66\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\r线程组2的取样器结果\rhread Name:线程组2 2-1\nSample Start: 2024-01-16 11:19:34 CST\nLoad time:3003\nConnect Time:1\nLatency:3003\nSize in bytes:231\nSent bytes:210\nHeaders size in bytes:165\nBody size in bytes:66\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\rSample Start 是请求发出的时间，可以观察到两个线程组内的 HTTP 请求在同一时刻发出，即 2024-01-16 11:19:34。因为两个线程组是并发、随机执行的。\n勾选独立运行每个线程组，运行结果 线程组1的取样器结果\rhread Name:线程组1 1-1\nSample Start: 2024-01-16 11:32:52 CST\nLoad time:3004\nConnect Time:1\nLatency:3004\nSize in bytes:231\nSent bytes:210\nHeaders size in bytes:165\nBody size in bytes:66\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\r线程组2的取样器结果\rhread Name:线程组2 2-1\nSample Start: 2024-01-16 11:32:55 CST\nLoad time:3003\nConnect Time:1\nLatency:3003\nSize in bytes:231\nSent bytes:210\nHeaders size in bytes:165\nBody size in bytes:66\nSample Count:1\nError Count:0\nData type (\"text\"|\"bin\"|\"\"):text\nResponse code:200\nResponse message:OK\rSample Start 是请求发出的时间，可以观察到两个线程组内的 HTTP 请求并非在同一时刻发出。具体而言，HTTP 请求1的请求发出时间是 2024-01-16 11:32:52，而 HTTP 请求2的请求发出时间是 2024-01-16 11:32:55。两者之间的时间差正好为三秒，与接口休眠的三秒相符，这表明两个线程组是顺序执行的。\n结语 当勾选了独立运行每个线程组选项时，能够确保测试计划中的相同类型线程组按照顺序执行。在某些特定的测试情况下，这个选项非常有用。相反，若未勾选 独立运行每个线程组时，线程组是并发执行。\n但线程组中的多个取样器并不会并发，而是在较短时间内发出全部请求，尤其是在取样器数量较多的情况下。\n因此，在模拟高并发时，如果需要多线程组、所有取样器请求并发，建议在测试计划中添加同步定时器（Synchronizing Timer）。\n同步定时器（Synchronizing Timer）可以确保在并发场景下的同一时间点触发多个线程组中多个取样器的请求，以更真实地模拟多用户同时访问系统的情况。这样的设置有助于提高测试的准确性和可靠性，使测试更符合实际应用场景。\n主线程结束后运行tearDown线程组 该选项主要适用于在取样器错误后配置的普通线程，并指定了在错误发生后要执行的动作，如停止测试或立即停止测试。\n勾选主线程结束后运行tearDown线程组后，当普通线程由于取样器错误而导致线程结束执行时，系统会继续执行 tearDown 线程。这意味着即使在测试中发生了错误，系统仍会在整个测试结束前执行 tearDown 线程，以确保在测试运行结束时执行一些清理或必要的操作。\n需要注意的是，在 JMeter 中，普通线程组的执行优先级大于 tearDown 线程组，因此 tearDown 线程组将会等待所有普通线程组执行完毕后才会执行。\n这一设置非常有用，可以确保在测试过程中出现错误时执行必要的清理步骤，同时允许根据具体情况选择在错误发生后是立即停止测试还是允许测试计划中其他线程组或线程继续执行。\n示例接口代码 1 2 3 4 5 6 @api.route(\u0026#39;/TestPlan1/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan1(): sleep(3)\t# 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39; 请求方式错误！\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;处理完毕\u0026#39;}) 示例Jmeter脚本* 测试计划下添加线程组\n在取样器错误后要执行的动作,勾选停止测试或立即停止测试\n测试计划下添加tearDown线程组\n线程组和tearDown线程组下添加同样的http请求\n名称分别为：线程组请求，tearDown线程组请求\n请求地址：HTTP://127.0.0.1:5000/TestPlan1/\n请求方式：GET\n线程组请求取样器下添加响应断言\n添加，输入值：1111\n测试计划下添加查看结果树\nPS：响应断言用于匹配实际响应信息，作为验证接口响应的一种手段。例如，示例接口响应的是 {'code': 200, 'data': '处理完毕'}，而添加的断言是 1111，这两者无法匹配，则可以判断该取样器请求存在错误。\n运行，查看结果树 不勾选主线程结束后运行tearDown线程组，运行结果 响应数据\rheaders\rHTTP/1.1 200 OK\nServer: Werkzeug/3.0.1 Python/3.12.1\nDate: Fri, 16 Jan 2024 14:52:02 GMT\nContent-Type: application/json\nContent-Length: 47\nConnection: close\rbody\r{\"code\": 200,\"data\": \"处理完毕\"}\r因为不勾选主线程结束后运行tearDown线程组，而且响应体{\u0026quot;code\u0026quot;: 200,\u0026quot;data\u0026quot;: \u0026quot;处理完毕\u0026quot;}与断言1111无法匹配，响应断言判断该取样器请求发生错误，所以只有线程组被执行完毕后，而 tearDown 线程组并未被执行。\n此时，修改响应断言为：{\u0026quot;code\u0026quot;:200,\n再运行。\n即使不勾选主线程结束后运行tearDown线程组，因为响应体{\u0026quot;code\u0026quot;: 200,\u0026quot;data\u0026quot;: \u0026quot;处理完毕\u0026quot;}与断言{\u0026quot;code\u0026quot;:200,匹配，响应断言判断该取样器请求正常，所以线程组被执行完毕后，执行 tearDown 线程组。\n勾选主线程结束后运行tearDown线程组,运行结果 响应断言改回为：1111\n即使响应断言判断请求发生错误，因为勾选主线程结束后运行tearDown线程组,线程组被执行后，tearDown 线程组紧接被执行。\n结语 在确保测试环境的可靠性和稳定性方面，通过勾选主线程结束后运行tearDown线程组以及配置线程组中的取样器错误后执行的动作，可以在主线程结束后执行 tearDown 线程组，从而进行一些关键的清理和还原操作。这一设置在测试流程中发生错误或异常情况时，能够确保系统状态的正确还原，为后续测试提供稳定的基础。\n具体而言，主线程结束后执行 tearDown 线程组的步骤可以被理解为测试执行的最后一道关口，确保在测试结束时执行特定的操作。通过配置线程组中的取样器错误后执行的动作，例如停止测试或立即停止测试，可以更加灵活地处理测试中的异常情况。\n这样的设置在以下方面发挥关键作用：\n环境清理： tearDown 线程组可以包含用于清理测试过程中创建的临时数据、资源或连接的操作。这有助于保持测试环境的整洁和可重复性。\n资源释放： 如果测试过程中涉及到占用系统资源的操作，例如文件打开、网络连接等，tearDown 线程组可以负责释放这些资源，避免资源泄露和系统负担。\n数据还原： 在测试期间可能对数据库或配置文件进行了修改，tearDown 线程组可以负责将这些更改还原，确保下一次测试能够在干净的环境中进行。\n错误处理： 配置线程组中的取样器错误后执行的动作可以根据具体需求选择停止测试或立即停止测试。这样的灵活性使得能够在测试遇到问题时及时采取适当的措施，防止进一步的不稳定性。\n通过精心配置这些选项，可以确保测试系统的可靠性和稳定性，同时为测试人员提供了在测试结束时进行必要清理和还原操作的机会，以确保下一次测试能够在一致的基础上进行。\n函数测试模式 若选择了此选项，并且监听组件（比如“查看结果树”）配置了将结果保存到文件中，JMeter将每次的请求结果记录到文件中。值得注意的是，这种做法相对消耗资源，在负载测试中并不建议勾选。然而，在平时脚本调试的情况下，可以考虑启用该选项。\n这样的设置主要适用于需要详细记录每次请求结果的情况，以便后续分析或排查问题。在负载测试中，由于可能生成大量的结果数据，将其全部保存到文件可能导致性能和资源开销的增加，因此需要谨慎使用。\n总体而言，这一功能的选择应该根据具体需求和测试目标来决定。在进行性能测试时，特别是在高并发负载下，建议避免勾选该选项以保持测试的高效性。然而，在脚本开发和调试阶段，启用此选项可以帮助更全面地了解每次请求的细节，有助于及时发现和解决问题。\n实际应用场景相对有限，因此在本文中不进行详细演示。\n添加目录或jar包到classpath 添加文件或 JAR 包功能主要用于调用外部的 JAR 包。当脚本需要引用外部的 Java 文件或 JAR 包时，可以通过将 JAR 包的路径添加到此功能中。这样，在 Beanshell 脚本中就可以通过 import 语句导入外部 JAR 包，并直接调用其中的方法。\n在后续的内容中，当涉及到 Beanshell 时，将详细阐述如何使用这一功能。这个特性提供了一种扩展 JMeter 功能的途径，使得用户可以方便地集成和调用外部 Java 类库，从而实现更复杂和灵活的测试脚本。\n总结 JMeter的测试计划是测试工作的主要组织结构，它定义了测试的执行流程、配置和执行的参数。在测试计划中，包括了多个关键组件，如线程组、tearDown线程组、HTTP取样器、响应断言等，它们构成了一个完整的测试计划。\n当你执行测试时，添加的所有所需组件和元件组成了一个有机整体，即一个完整的测试计划。这个测试计划反映了你对系统性能和功能的验证方式以及测试场景的设计。\n本篇主要探讨了测试计划组件面板中各元素的使用，这包括了配置用户定义的变量、定义并发用户行为的线程组、定义进测试后清理的tearDown线程组，这些元素的组合和配置，直接影响着测试的有效性和准确性。\n在JMeter中，设计一个强大且高效的测试计划需要综合考虑系统特性、测试目标和性能需求。合理配置这些组件，有效运用各种元素，是确保测试计划成功执行和提取有价值信息的关键步骤。\n在下一篇章中，EtherealBoyJiang将引领读者深入探讨线程组的重要性和使用方法。线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。\n","date":"2024-01-26T00:00:00Z","image":"https://etherealboyjiang.github.io/Jiang/img/Jmeter/0.png","permalink":"https://etherealboyjiang.github.io/Jiang/p/jmeter%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/","title":"Jmeter测试计划"},{"content":"\nJMeter 环境安装及配置 在使用 JMeter 之前，需要配置相应的环境，包括安装JDK和JMeter。\n首先，了解一下JDK，它就是Java的开发工具包。\nJMeter 是使用 Java 编写的。一般来说，只需要安装 JRE（Java 运行时环境）就可以运行 JMeter，因为 JRE 包含了运行 Java 应用程序所需的组件。那么为什么建议安装 JDK 呢？\n如果你想要在 JMeter 中使用一些插件、进行脚本开发、编译测试计划等高级功能，安装 JDK 可能会更有帮助，因为 JDK 包含了 JRE，并且还提供了编译 Java 代码所需的工具，比如 javac。此外，一些场景下，比如进行 HTTPS 压力测试，需要使用 JDK 中的 keytool 工具。\n确保正确配置JDK和JMeter环境，可以让你更灵活地应对不同的测试需求\nJDK 1.下载JDK JDK下载地址示例环境为Windows，读者应根据实际环境下载JDK的安装包。推荐下载exe文件，安装方便快捷。\rhttps://www.oracle.com/java/technologies/downloads/#jdk21-windows\r2.安装JDK 建议在安装之前在D盘或C盘下新建一个下新建一个Tools 文件夹。在安装 JDK 时，修改安装目录为Tools文件夹。这样做的好处在于方便管理和配置环境变量。\n接下来就是一直下一步就行。\n配置JDK系统变量、环境变量 系统变量和环境变量是计算机系统中的两个重要概念，它们用于存储和管理系统或应用程序运行过程中需要使用的信息。\n系统变量是指在操作系统级别上设置的一些全局信息，用于控制和影响整个计算机系统的行为。 这些变量通常由操作系统或系统管理员配置，用于存储系统范围的配置参数和信息。系统变量可以影响所有用户和应用程序的行为。 如PATH是一个常见的系统变量，它存储了操作系统在哪些目录中查找可执行文件的信息。\n环境变量是在操作系统或应用程序运行过程中设置的一些动态变量，用于影响当前进程的行为。 环境变量提供了一种将信息传递给正在运行的程序的方法，以便程序根据这些变量的值来调整其行为。 如PATH变量中的值就是执行文件的环境变量。\n总结来说，系统变量是操作系统级别的全局配置，而环境变量是在运行过程中用于传递信息给正在执行的程序的配置。在许多情况下，环境变量的值可以由用户或程序员进行配置，以影响特定应用程序或进程的行为。\n不要随意改动环境变量，否则可能造成系统死机。\r新建JAVA_HOME系统变量 右键此电脑-属性-高级系统设置-环境变量，系统变量-新建。\n变量名：JDK\n变量值：C:\\Tools\\JDK（JDK安装目录） 或者浏览目录进行选择（Windows11）\n然后确定。\nPath中新建JAVA_HOME的环境环境 系统变量中找到Path，选中，点击编辑，进入Path系统变量窗口，新建两条环境变量。\n第一条：%JAVA_HOME%\\bin;\n第二条：%JAVA_HOME%\\jre\\bin;\nps：windows11好像不需要输入最后的\n然后一路确定。\nJmeter JMeter 是一个独立的 Java 应用程序，它不依赖于系统注册表或其他系统级配置。所以它能够在不同操作系统上运行而无需进行安装。只需要下载完成后，将 ZIP 文件解压缩到指定的目录。 在解压缩后的目录中找到 JMeter 启动脚本（例如 jmeter.bat 或 jmeter.sh），运行该脚本以启动 JMeter。\n下载JmeterZIP包 历史版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://archive.apache.org/dist/jmeter/binaries/\r最新版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://jmeter.apache.org/download_jmeter.cgi\r解压到目录 建议解压到D:\\Tools目录下,方便管理。\n汉化Jmeter界面 修改Jmeter/bin/jmeter.properties，40行增加language=zh_CN。然后保存。\n发送启动文件到桌面快捷方式 启动Jmeter 双击桌面上的 JMeter 快捷方式，等待脚本运行，然后 JMeter 界面将会显示出来。\n快速使用 我们可以使用最简单的JMeter脚本来快速进行一次接口请求。这个脚本包括测试计划、线程组、取样器（Sampler）以及查看结果器（View Results Tree）。\n在测试计划中，我们定义了整个测试的基本设置。线程组用于模拟用户，而取样器则代表了具体的请求。查看结果器则用于查看请求的详细结果。\n通过这个简单的脚本，我们能够迅速进行一次接口请求测试，为后续更复杂的测试做好基础工作。这个基本结构也为我们学习更多JMeter的高级功能打下了基础。\n示例接口 1 2 3 4 5 @api.route(\u0026#39;/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return jsonify({\u0026#39;code\u0026#39;: 400, \u0026#39;data\u0026#39;: \u0026#39;ERROR: The request method is not GET!\u0026#39;}) return jsonify({\u0026#39;code\u0026#39;: 200, \u0026#39;data\u0026#39;: \u0026#39;It is successful!\u0026#39;}) 示例Jmeter脚本 测试计划下添加线程组\n右键测试计划-添加-线程（用户）-线程组\n测试计划下添加查看结果树\n右键测试计划-添加-监听器-查看结果树\n线程组下添加HTTP请求\n右键线程组-添加-取样器-HTTP请求\n请求地址：HTTP://127.0.0.1:5000/QuickUse/\n请求方式：GET\n运行（点击上方绿色三角形），查看结果树 请求数据\rheaders\rConnection: keep-alive\nHost: 127.0.0.1:5000\nUser-Agent: Apache-HttpClient/4.5.14 (Java/20.0.2)\rbody\rGET http://127.0.0.1:5000/QuickUse/\nGET data:\n[no cookies]\rrespond\rheaders\rHTTP/1.1 200 OK\nServer: Werkzeug/3.0.1 Python/3.12.1\nDate: Mon, 15 Jan 2024 03:39:26 GMT\nContent-Type: application/json\nContent-Length: 40\nConnection: close\rbody\r{\"code\": 200, \"data\": \"It is successful!\"}\r结尾 本篇主要介绍JMeter的环境配置以及初体验，为后续的JMeter之旅做好准备。在这一章节中，我们将了解如何配置JMeter的环境，以及如何进行简单的接口测试。\n接下来的篇章EtherealBoyJiang将深入探讨JMeter的测试计划，帮助读者更好地利用这个强大的性能测试工具。\n","date":"2024-01-25T00:00:00Z","image":"https://etherealboyjiang.github.io/Jiang/img/Jmeter/0.png","permalink":"https://etherealboyjiang.github.io/Jiang/p/jmeter%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"Jmeter环境配置"},{"content":"前言 为什么要撰写这样一个教程呢？ 深入学习Jmeter\n温故而知新，通过编写教程，我将更深入地学习JMeter。尽管我已经使用JMeter很长时间，但还有许多元件我并不十分了解。为了创作一个详尽且实用的JMeter教程，我需要精通JMeter的各个元件。因此，编写教程的过程成为了我的学习过程，通过反复回顾和整理知识，我能够更全面地掌握JMeter的使用技巧\n分享知识\n我深信知识具有强大力量，而这种力量应该共享。我愿意将我的所学分享给志同道合的朋友——也就是你们。通过分享知识，我不仅能够为他人提供帮助，还能够在这个过程中体验到一种内在的满足感。\n结识朋友\n这是我的第一个教程，后续也会编辑更多的教程。希望能通过这一行为与各位取得交流，成为朋友，与大家一起讨论更多的事情。\n关于Jmeter JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。\nJMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。\n另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n我们为什么使用Jmeter 开源免费，基于Java编写，可集成到其他系统可拓展各个功能插件\n支持接口测试，压力测试等多种功能，支持录制回放，入门简单\n相较于自己编写框架活其他开源工具，有较为完善的UI界面，便于接口调试\n多平台支持，可在Linux，Windows，Mac上运行selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。\n主要组件介绍 测试计划(Test Plan)\n是使用JMeter进行测试的起点，它是其它JMeter测试元件的容器。\n线程组(Thread Group)\n代表一定数量的并发用户，它可以用来模拟并发用户发送请求。\n取样器(sampler)\n定义实际的请求内容，被线程组包含，我们主要用HTTP请求。\n监听器(Listener)\n负责收集测试结果，同时也被告知了结果显示的方式。我们常用的包括：聚合报告、察看结果树、用表格查看结果，都支持将结果数据写入文件。其他的添加上去看看就行。\n逻辑控制器(Logic Controller)\n可以自定义JMeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。\n其分为循环控制器和事务控制器。\n断言(Assertions)\n可以用来判断请求响应的结果是否如用户所期望的。它可以用来隔离问题域，即在确保功能正确的前提下执行压力测试。这个限制对于有效的测试是非常有用的。\n配置元件(Config Element)\n维护Sampler需要的配置信息，并根据实际的需要会修改请求的内容。我们主要在参数化中用到CSV Data Set Config。\n前置处理器(Pre Processors)和后置处理器(Post Processors)\n负责在生成请求之前和之后完成工作。前置处理器常常用来修改请求的设置，后置处理器则常常用来处理响应的数据。我们主要在动态关联中用到后置处理器的正则表达式提取器。\n定时器(Timer)\n负责定义请求之间的延迟间隔。\n执行顺序(Execution sequence)\n配置元件、前置处理器、定时器、取样器、后置处理器、断言、监听器\n工作流程 JMeter通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式计算目标服务器的统计和显示性能度量。\n内容引用 Jmeter测试组件介绍|EMQ本系列教程中部分组件介绍文本引用于此\rhttps://www.emqx.com/zh/blog/introduction-to-jmeter-test-components#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E7%BB%84\r鸟哥教程本系列教程中部分组件介绍文本引用于此\rhttps://www.niaoge.com/jmeter/jmeter-index.html\r示例接口代码 本系列文章中所有示例接口皆由python编写，python版本为3.12.1，如要使用示例接口请安装python3.12.1与pycharm。\n下载地址压缩包内包含源码和使用说明\r说明 本文基于JDK21、Jmeter-5.6.3测试编写，可能不适用于历史版本及未来版本。\n如果Jmeter在后续的新版本中有所变化，或者文中有错漏的地方，请联系EtherealBoyJiang，EtherealBoyJiang感激不尽。\n结尾 对于测试人员来说，JMeter是一款非常强大的接口测试工具，尤其在性能测试方面表现出色。\n希望读者们通过EtherealBoyJiang编写的系列教程，能够熟练掌握JMeter的使用。本系列教程旨在为读者提供全面而深入的理解，使读者将能够深入了解JMeter的各项功能，并掌握如何在性能测试中有效地利用这些功能。提高读者的技能水平，能够更自信地应对各类测试任务。能够为项目的成功实施提供有力的支持。\n对EtherealBoyJiang来说，能够帮助到读者是一件莫大的荣幸，期待更多读者通过本系列教程获得成长。\n","date":"2024-01-23T00:00:00Z","image":"https://etherealboyjiang.github.io/Jiang/img/Jmeter/0.png","permalink":"https://etherealboyjiang.github.io/Jiang/p/jmeter%E5%89%8D%E8%A8%80/","title":"Jmeter前言"}]